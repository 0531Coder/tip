# 排序

- ###　移动方式

  1. **直接移动**： 直接交换存储数据的位置。
  
  2. **逻辑移动**：不会移动数据的位置，仅改变指向这些数据的值。

- ### 排序的分类

  1. **内部排序**：排序的数据量小，可以完全在内存进行排序。
  
  2. **外部排序**：排序的数据量无法直接在内存中进行排序，而必须使用辅助存储器。

  常见的内部排序有：冒泡排序，选择排序，插入排序，合并排序，快速排序，堆积排序，
  希尔排序，基数排序等。
  
  常见的外部排序有：直接合并排序，k路合并，多相合并等
  
  ![二叉树](../pics/data/数据结构_22.png)
  
- ### 排序算法的选择
  大约可以考虑一下三种因素。
  - **是否稳定**

    稳定的排序是指数据在经过排序后，两个相同键值的数据仍保持原来的数据。

    ```
    原始数据顺序：  7(左)  2   9   7(右) 6
    稳定的排序：    2    6  7(左) 7(右) 9
    不稳定的排序：  2    6  7(右) 7(左) 9
    ```
    
  - **时间复杂度**

  - **空间复杂度**
  
  ![二叉树](../pics/data/数据结构_23.png)
  
- ### 冒泡排序

  适用于数据量较小且有部分数据已经经过排序的情况。

  ```
  步骤:
  1. 将序列当中的左右元素依次比较，保证右边的元素始终大于左边的元素。
  2. 对序列当中剩下的n-1个元素再次执行步骤1。
  3. 对于长度为n的序列，一共需要执行n-1轮比较
  
  简单来说，第一次确定最大值，第二次确定第二大置，依次完成排序。
  ```
  
  ![二叉树](../pics/data/数据结构_24.gif)
  
  ```java
  public class Main {
      public static void main(String args[]){
          int[] array=new int[]{6,5,8,4,36,78,9,46,2,5,0,7};
          for (int i: bubbleSort(array)){
              System.out.print(i+" ");
          }
      }
      public static int[] bubbleSort(int[] array){
        if (array==null || array.length<1){
            return null;
        }
        for(int i=0;i<array.length;i++){
            for (int j=1;j<array.length-i;j++){
                if (array[j]<array[j-1]){
                    int temp=array[j];
                    array[j]=array[j-1];
                    array[j-1]=temp;
                }
            }
        }
        return array;
      }
  }
  ```

- ### 简单选择排序 

  适用于数据量较小且有部分数据已经经过排序的情况。
 
  ```
  步骤：
  1. 从待排序序列中，找到关键字最小的元素；
  2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；
  3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。
  ```
  
  ```java
  public class Main {
      public static void main(String args[]){
          int[] array=new int[]{6,5,8,4,36,78,9,46,2,5,0,7};
          for (int i: simpleSelectionSort(array)){
              System.out.print(i+" ");
          }
      }
      public static int[] simpleSelectionSort(int[] array){
         for(int j=0;j<array.length;j++) {
             int min=j;
             for (int i = j; i < array.length; i++) {
                 if (array[min] > array[i]) {
                     min = i;
                 }
             }
             int temp = array[j];
             array[j] = array[min];
             array[min] = temp;
         }
         return array;
      }
  }
  ```

- ## 参考
  - http://www.jianshu.com/p/7d037c332a9d
  - 《图解数据结构-java版》