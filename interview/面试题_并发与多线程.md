#### 01. java用（）机制实现了进程之间的同步执行
```
A. 监视器
B. 虚拟机
C. 多个CPU
D. 异步调用

正解： A

解析： 监视器机制即锁机制
```

#### 02. 线程安全的map在JDK 1.5及其更高版本环境 有哪几种方法可以实现?
```
A. Map map = new HashMap()
B. Map map = new TreeMap()
C. Map map = new ConcurrentHashMap();
D. Map map = Collections.synchronizedMap(new HashMap());

正解：CD

解析： 1. HashMap,TreeMap 未进行同步考虑，是线程不安全的。
      2. HashTable 和 ConcurrentHashMap 都是线程安全的。区别在于他们对加锁的范围不同，HashTable 对整张Hash表进行加锁，而ConcurrentHashMap将Hash表分为16桶(segment)，每次只对需要的桶进行加锁。
      3. Collections 类提供了synchronizedXxx()方法，可以将指定的集合包装成线程同步的集合。比如，
      List  list = Collections.synchronizedList(new ArrayList());
      Set  set = Collections.synchronizedSet(new HashSet())
```

#### 03. 下列关于java并发的说法中正确的是：
```
A. copyonwritearraylist适用于写多读少的并发场景
B. readwritelock适用于读多写少的并发场景
C. concurrenthashmap的写操作不需要加锁，读操作需要加锁
D. 只要在定义int类型的成员变量i的时候加上volatile关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了

正解：B
解析：CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。
     ReadWriteLock 当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据 。适用于 读取远远大于写入的操作。
     ConcurrentHashMap是一个线程安全的Hash Table，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。
```

#### 04. 下列关于JAVA多线程的叙述正确的是（）
```
A. 调用start()方法和run()都可以启动一个线程
B. CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程
C. Callable类的call()方法可以返回值和抛出异常
D. 新建的线程调用start()方法就能立即进行运行状态

正解：C
解析： CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。
      它要做的事情是，让一组线程到达一个屏障（也可以叫做同步点时被阻塞），
      直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续执行。

      CountDownLatch允许一个或多个线程等待其他线程操作完成。
```

#### 05. 以下是java concurrent包下的4个类，选出差别最大的一个
```
A. Semaphore
B. ReentrantLock
C. Future
D. CountDownLatch

正解：C

解析：
   1、答案选C。
       a、它是个接口。
       b、别的类都处理线程间的关系，处理并发机制，但该类只用于获取线程结果。
   2、Future表示获取一个正在指定的线程的结果。对该线程有取消和判断是否执行完毕等操作。
   3、CountDownLatch 是个锁存器，他表示我要占用给定的多少个线程且我优先执行，我执行完之前其他要使用该资源的都要等待。
   4、 Semaphore，就像是一个许可证发放者，也想一个数据库连接池。证就这么多，如果池中的证没换回来，其他人就不能用。
   5、 ReentrantLock 和 synchronized一样，用于锁定线程
```

#### 06. 假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（）
```
public static void main(String[]args)throws Exception {
    final Object obj = new Object();
    Thread t1 = new Thread() {
        public void run() {
            synchronized (obj) {
                try {
                    obj.wait();
                    System.out.println("Thread 1 wake up.");
                } catch (InterruptedException e) {
                }
            }
        }
    };
    t1.start();
    Thread.sleep(1000);//We assume thread 1 must start up within 1 sec.
    Thread t2 = new Thread() {
        public void run() {
            synchronized (obj) {
                obj.notifyAll();
                System.out.println("Thread 2 sent notify.");
            }
        }
    };
    t2.start();
}

A. Thread 1 wake up
   Thread 2 sent notify.
B. Thread 2 sent notify.
   Thread 1 wake up
C. A、B皆有可能
D. 程序无输出卡死

正解： B
解析： t1 启动后执行 obj.wait() 时，进入阻塞状态，让出时间片并释放锁，
      等待其他线程的唤醒。然后 t2 获取到 obj，并唤醒 t1，待 t2 执行完毕，
      释放锁后，t1 再继续执行。
```

#### 07.截止JDK1.8版本,java并发框架支持锁包括?
```
A. 读写锁
B. 自旋锁
C. X锁
D. 乐观锁
F. 排他锁

正解：ABD
解析：截止JDK1.8版本,java并发框架支持锁包括： 读写锁， 自旋锁， 乐观锁。
   锁的分类：
   1、自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁
   2、阻塞锁 被阻塞的线程，不会争夺锁。
   3、可重入锁 多次进入改锁的域
   4、读写锁
   5、互斥锁 锁本身就是互斥的
   6、悲观锁 不相信，这里会是安全的，必须全部上锁
   7、乐观锁 相信，这里是安全的。
   8、公平锁 有优先级的锁
   9、非公平锁 无优先级的锁
   10、偏向锁 无竞争不锁，有竞争挂起，转为轻量锁
   11、对象锁 锁住对象
   12、线程锁
   13、锁粗化 多锁变成一个，自己处理
   14、轻量级锁 CAS 实现
   15、锁消除 偏向锁就是锁消除的一种
   16、锁膨胀 jvm实现，锁粗化
   17、信号量 使用阻塞锁 实现的一种策略
   18、排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。
```

#### 08. 关于sleep()和wait()，以下描述错误的一项是（ ）
```
A. sleep是线程类（Thread）的方法，wait是Object类的方法；
B. sleep不释放对象锁，wait放弃对象锁
C. sleep暂停线程、但监控状态仍然保持，结束后会自动恢复
D. wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态

正解：D
解析：notity()和notifyAll()两个方法均可，应该进入就绪状态而不是运行状态。
```

#### 09. 下列关于java 中的 wait()方法和 sleep()方法的区别描述错误的是？
```
A. wait()方法属于Object类，二sleep()属于Thread类
B. 调用wait()方法的时候，线程会放弃对象锁
C. 调用sleep()方法的过程中，线程不会释放对象锁
D. sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程

正解： D
解析：1. 这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。
     sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。
     2、 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。
     sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源敏感词线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待敏感词线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。
     Thread.Sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”。
     3、使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 
      synchronized(x){ 
         x.notify() 
        //或者wait() 
      }
     4、sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常
```

## 习题来源或参考：
   - 牛客网