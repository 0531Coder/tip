#### 01. 以下代码结果是什么？
```
public class foo {
public static void main(String sgf[]) {
StringBuffer a=new StringBuffer(“A”);
StringBuffer b=new StringBuffer(“B”);
operate(a,b);
System.out.println(a+”.”+b);
}
static void operate(StringBuffer x,StringBuffer y) {
x.append(y);
y=x;
}
}

A. 代码可以编译运行，输出“AB.AB”。
B. 代码可以编译运行，输出“A.A”。
C. 代码可以编译运行，输出“AB.B”。
D. 代码可以编译运行，输出“A.B”。

正解: C
解析：对象的传递实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以"y=x"不会影响b的值。
```

#### 02. 如下语句通过算术运算和逻辑运算之后i和 j的结果是()
```
int i=0;
int j=0;
if((++i>0)||(++j>0)){
//打印i,j的值
}
A. i=0;j=0
B. i=1;j=1
C. i=0;j=1
D. i=1;j=0

正解: D
解析: &&和||为短路逻辑
```

#### 03. 以下程序的输出结果为()
```
Class Base{
  public Base(String s){
    System.out.println("B");
  }
}
public class Derived extends Base{
  public Derived(String s){
   System.out.println("D");
  }
  public static void main(String args[]){
    new Derived("C");
  }
}

A. BD
B. DB
C. C
D. 编译错误

正解: D

解析：子类构造方法在调用时必须先调用父类的，由于父类没有无参构造，必须在子类中显式调用，修改子类构造方法如下即可：
   public Derived(String s){
           super("s");
           System.out.print("D");
       }
```

04. 在基本 JAVA 类型中，如果不明确指定，整数型的默认是 ***int*** 类型，带小数的默认是 ***double*** 类型？

05. HashMap通过***拉链法***法解决哈希冲突
```
1、开放定址法 
   当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。
2  拉链法
   将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。拉链法适合未规定元素的大小。
```

06. 对Collection和Collections描述正确的是()
```
A. Collection是java.util下的类，它包含有各种有关集合操作的静态方法
B. Collection是java.util下的接口，它是各种集合结构的父接口
C. Collections是java.util下的接口，它是各种集合结构的父接口
D. Collections是java.util下的类，它包含有各种有关集合操作的静态方法

正解： BD
```

07. 下面为true的是？
```
Integer i = 42;
Long l = 42l;
Double d = 42.0;

A. (i == l)
B. (i == d)
C. (l == d)
D. i.equals(d)
E. d.equals(l)
F. i.equals(l)
G. l.equals(42L)

正解: G

解析：引用类型在没有遇到算数运算时是不会自动拆箱成基本类型的，所以“==”的比较肯定因为类型不同而编译报错，故ABC错误。
public boolean equals(Object obj) {
        if (obj instanceof Integer) {
            return value == ((Integer)obj).intValue();
        }
        return false;
    }
故DEF错误
```

8. 下面哪项技术可以用在WEB开发中实现会话跟踪实现？
```
A. session
B. Cookie
C. 地址重写
D. 隐藏域
正解：ＡＢＣＤ

解析：
会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。
HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。
有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。
1）.隐藏表单域：<input type="hidden">，非常适合步需要大量数据存储的会话应用。
2）.URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。
3）.Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP
响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个
Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至
在客户端计算机重启后它仍可以保留其值
4）.Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话
```


## 习题来源：
   - 牛客网