#### 01. 以下代码结果是什么？
```
public class foo {
public static void main(String sgf[]) {
StringBuffer a=new StringBuffer(“A”);
StringBuffer b=new StringBuffer(“B”);
operate(a,b);
System.out.println(a+”.”+b);
}
static void operate(StringBuffer x,StringBuffer y) {
x.append(y);
y=x;
}
}

A. 代码可以编译运行，输出“AB.AB”。
B. 代码可以编译运行，输出“A.A”。
C. 代码可以编译运行，输出“AB.B”。
D. 代码可以编译运行，输出“A.B”。

正解: C
解析：对象的传递实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以"y=x"不会影响b的值。
```

#### 02. 如下语句通过算术运算和逻辑运算之后i和 j的结果是()
```
int i=0;
int j=0;
if((++i>0)||(++j>0)){
//打印i,j的值
}
A. i=0;j=0
B. i=1;j=1
C. i=0;j=1
D. i=1;j=0

正解: D
解析: &&和||为短路逻辑
```

#### 03. 以下程序的输出结果为()
```
Class Base{
  public Base(String s){
    System.out.println("B");
  }
}
public class Derived extends Base{
  public Derived(String s){
   System.out.println("D");
  }
  public static void main(String args[]){
    new Derived("C");
  }
}

A. BD
B. DB
C. C
D. 编译错误

正解: D

解析：子类构造方法在调用时必须先调用父类的，由于父类没有无参构造，必须在子类中显式调用，修改子类构造方法如下即可：
   public Derived(String s){
           super("s");
           System.out.print("D");
       }
```

#### 04. 在基本 JAVA 类型中，如果不明确指定，整数型的默认是 ***int*** 类型，带小数的默认是 ***double*** 类型？

#### 05. HashMap通过***拉链法***法解决哈希冲突
```
1、开放定址法 
   当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。
2  拉链法
   将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。拉链法适合未规定元素的大小。
```
 
#### 06. 对Collection和Collections描述正确的是()
```
A. Collection是java.util下的类，它包含有各种有关集合操作的静态方法
B. Collection是java.util下的接口，它是各种集合结构的父接口
C. Collections是java.util下的接口，它是各种集合结构的父接口
D. Collections是java.util下的类，它包含有各种有关集合操作的静态方法

正解： BD
```

#### 07. 下面为true的是？
```
Integer i = 42;
Long l = 42l;
Double d = 42.0;

A. (i == l)
B. (i == d)
C. (l == d)
D. i.equals(d)
E. d.equals(l)
F. i.equals(l)
G. l.equals(42L)

正解: G

解析：引用类型在没有遇到算数运算时是不会自动拆箱成基本类型的，所以“==”的比较肯定因为类型不同而编译报错，故ABC错误。
public boolean equals(Object obj) {
        if (obj instanceof Integer) {
            return value == ((Integer)obj).intValue();
        }
        return false;
    }
故DEF错误
```

#### 8. 下面哪项技术可以用在WEB开发中实现会话跟踪实现？
```
A. session
B. Cookie
C. 地址重写
D. 隐藏域
正解：ＡＢＣＤ

解析：
会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。
HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。
有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。
1）.隐藏表单域：<input type="hidden">，非常适合步需要大量数据存储的会话应用。
2）.URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。
3）.Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP
响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个
Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至
在客户端计算机重启后它仍可以保留其值
4）.Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话
```

#### 9. 经过强制类型转换以后，变量a, b的值分别为（ ）short a = 128; byte b = (byte) a;
```
A. 128  127
B. 128  -128
C. 128  128
D. 编译错误

正解: B
解析: java int 128转为byte，值：
128为正数，补码为10000000（前面24个0省略），变成byte，
只剩下10000000（byte为1个字节），因为开头是1，所以为负数。
即1个负数的补码是10000000。反码是01111111，原码是1000000。
是128.因为是负数，所以是-128。
```

#### 10. 以下代码的输出结果是？
```
public class B
{
    public static B t1 = new B();
    public static B t2 = new B();
    {
        System.out.println("构造块");
    }
    static
    {
        System.out.println("静态块");
    }
    public static void main(String[] args)
    {
        B t = new B();
    }
}

A. 静态块 构造块 构造块 构造块
B. 构造块 静态块 构造块 构造块
C. 构造块 构造块 静态块 构造块
D. 构造块 构造块 构造块 静态块

正解： C
解析： 有多个静态变量或块时，按声明顺序加载
```

#### 11. 以下程序的输出结果是？
```
class C {
    C() {
        System.out.print("C");
    }
}
class A {
    C c = new C();
    A() {
        this("A");
        System.out.print("A");
    }
    A(String s) {
        System.out.print(s);
    }
}
class Test extends A {
    Test() {
        super("B");
        System.out.print("B");
    }
    public static void main(String[] args) {
        new Test();
    }
}

A. BB
B. CBB
C. BAB
D. None of the above

正解：B
解析：首先new了一个子类对象，那么就要调用构造方法来初始化该子类对象，
     但是该类继承自A，所以要先调用父类的构造方法，
     这里通过super("B")显示的调用了父类的带参构造。
     执行父类的带参构造前要先对父类中的对象进行初始化，
     对父类中的c成员进行初始化，调用了C类的无参构造，所以调用顺序为：
     先调用C类的无参构造
     再调用A类的带参构造
     最后调用调用子类的构造 
```

#### 12. 以下程序的输出结果是什么？
```
double d1=-0.5;
System.out.println("Ceil d1="+Math.ceil(d1));
System.out.println("floor d1="+Math.floor(d1));

A. Ceil d1=-0.0
   floor d1=-1.0
B. Ceil d1=0.0
   floor d1=-1.0
C. Ceil d1=-0.0
   floor d1=-0.0
D. Ceil d1=0.0
   floor d1=0.0
E. Ceil d1=0
   floor d1=-1
  
正解： A
解析：无论是ceil还是floor
     如果参数是 NaN、无穷、正 0、负 0，那么结果与参数相同，
     如果是 -0.0，那么其结果是 -0.0
```

#### 13. ArrayList list = new ArrayList(20);中的list扩充几次
```
A. 0
B. 1
C. 2
D. 3

正解: A
解析：默认ArrayList的长度是10个，
     所以如果你要往list里添加20个元素肯定要扩充一次（扩充为原来的1.5倍），
     但是这里显示指明了需要多少空间，所以就一次性为你分配这么多空间，
     也就是不需要扩充了。
```

#### 14. 以下语句的执行结果是什么？
```
1+”10”+3+”2”

A. ”11032”
B. “16”
C. 16
D. “32101”

正解： A
解析：字符串拼接
```

#### 15. 关于下面代码片段叙述正确的是（）
```
byte b1=1,b2=2,b3,b6; 
final byte b4=4,b5=6; 
b6=b4+b5; 
b3=(b1+b2); 
System.out.println(b3+b6);

A. 输出结果：13
B. 语句：b6=b4+b5编译出错
C. 语句：b3=b1+b2编译出错
D. 运行期抛出异常

正解：C
1.需要强制转换（向下转型）。
2.没有final修饰的变量相加后会被自动提升为int型，与目标类型byte不相容，要向下转型。
```

## 习题来源或参考：
   - 牛客网