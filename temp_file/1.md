## 是第一个tomcat向netty服务器发送请求，再由netty向第二个tomcat发送HTTP请求的意思？还是第一个程序的SpringMVC直接整合netty?


## 是第一种的话

我认为加这一层netty没有意义，加上这一层后第一个Tomcat的HTTP线程还得先调用netty，netty调用第二个tomcat返回结果给第一个tomcat，然后再响应请求。netty的异步只是netty这个中间层IO的异步，第一个HTTP请求还是阻塞的，多出来的netty反而多消耗性能了。

第一个tomcat的HTTP请求直接调用第二个tomcat问题在于，每次HTTP请求都挺耗时，第一个tomcat的线程就会被一直占用，HTTP请求线程总数有限，有可能请求处理线程枯竭。所以最好把一个程序需要发送HTTP请求的地方变成异步的。
异步的方式有：
1. servlet3是支持异步的，springmvc的WebAsyncTask，DeferredResult，@Async 都可以实现异步
2. spring 5的webflux可以异步的，非阻塞，事件驱动的服务，跟RxJava和node类似
3. springboot支持undertow，undertow支持NIO，同时也支持servlet3.1标准

## 是第二种的话
也是实现第一个程序异步的一种方式，这样是有意义的，可以降低第一个程序的HTTP请求线程枯竭的概率