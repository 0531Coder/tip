1. 不使用等待/通知机制实现线程间通信。
   > 可使用轮询机制实现，比如用while语句一直查询，但会浪费CPU的资源

2. ### 等待/通知机制的实现

   Object类的wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到被再次唤醒。
   
   Object类的notify()方法可以随机唤醒等待队列中等待同一共享资源的***一个***线程，并使该线程退出等待队列，进入可运行的状态，也就是notify()方法仅通知"一个"线程。
   
   Object类的notifyAll()方法可以使所有正在等待队列中等待同一资源的***全部***线程从等待状态退出，进入可运行的状态。此时，优先级最高的线程执行，但也有可能随机执行，这要取决于JVM的实现。
   
   在调用wait()或notify()方法之前，必须获得该对象的对象级别锁，即只能在同步方法或者同步块中调用wait()方法，在执行wait()方法之后，当前线程释放锁。
   
   在执行notify()方法后，当前线程不会立刻释放该对象锁，呈wait状态的线程并不能马上获取该对象锁，要等执行notify()方法的线程将程序执行完，也就是退出synchronized代码块后，当前线程才会释放锁。
   
3. ### 线程状态切换
    ![等待通知_01](../../pics/等待通知_01.jpg)
   
    1. 新建一个线程后，调用它的start()方法,系统会为此线程分配CPU资源，使其处于Runnable(可运行)状态，这是一个准备的阶段。如果线程抢占到CPU资源，此线程就处于Running(运行)状态。
    
    2. Runnable状态和Running状态因为CPU资源的抢占可互换。线程从Running状态进入Runnable状态情况大致分为5种:
       
       - 调用sleep()方法后经过的时间超过了指定的睡眠时间。
       
       - 线程调用堵塞IO已经返回，阻塞方法将执行完毕。
       
       - 线程成功地获得了试图同步的监视器。
       
       - 线程正在等待某个通知，其他发出了通知。
       
       - 处于挂起状态的线程调用了resume恢复方法。
       
    3. Blocked状态是阻塞状态。例如遇到了一个IO的操作，此时CPU会处于空闲状态，可能会把CPU时间片分配给其他线程，这时也可以称之为"暂停"状态.Blocked状态结束后，进入Runnable状态，等待线程重新分配资源。出现Blocked情况大致分为5种：
       
       - 线程调用sleep状态，主动放弃占用的处理器资源。
       
       - 线程调用了阻塞式IO方法，在该方法返回前，该线程被堵塞。
       
       - 线程试图获取一个同步监视器，但该监视器正在被其他线程持有。
       
       - 线程等待某个通知。
       
       - 程序调用了suspend方法该线程挂起。(此方法易导致死锁)
       
    4. run()方法结束后进入销毁状态，整个线程执行完毕。
    
    > 每个锁对象都有两个队列，一个就绪队列，一个阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被堵塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；反之，一个线程被wait之后，就会进入堵塞队列，等待下一次被唤醒。
    
    
   
#####参考:
- 《JAVA多线程编程核心技术》
- http://www.cnblogs.com/dolphin0520/p/3920357.html